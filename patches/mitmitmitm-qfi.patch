diff --git a/test/e2e/upg_e2e.go b/test/e2e/upg_e2e.go
index 98ccfdc..33899b5 100644
--- a/test/e2e/upg_e2e.go
+++ b/test/e2e/upg_e2e.go
@@ -514,6 +514,193 @@ func describePDRReplacement(f *framework.Framework) {
 	})
 }
 
+var _ = ginkgo.Describe("QFI matching and insertion", func() {
+	describePDUSessContExtHdrQFI("IPv4", framework.UPGIPModeV4)
+	describePDUSessContExtHdrQFI("IPv6", framework.UPGIPModeV6)
+})
+
+func describePDUSessContExtHdrQFI(
+	title string, mode framework.UPGIPMode,
+) {
+	ginkgo.Describe(title, func() {
+		describePDUSessContExtHdrQFI1("UL QFI matching and DL QFI insertion provisioned", mode, true, true)
+		describePDUSessContExtHdrQFI1("no UL QFI matching and DL QFI insertion provisioned", mode, false, true)
+		describePDUSessContExtHdrQFI1("UL QFI matching and no DL QFI insertion provisioned", mode, true, false)
+	})
+
+}
+
+func describePDUSessContExtHdrQFI1(
+	title string, mode framework.UPGIPMode,
+	qfiULMatchingProvisioned bool,
+	qfiDLInsertionProvisioned bool,
+) {
+	ginkgo.Context(title, func() {
+		describePDUSessContExtHdrQFI2("1 ext. header has valid qfi",
+			mode, qfiULMatchingProvisioned, qfiDLInsertionProvisioned, false, 1)
+		describePDUSessContExtHdrQFI2("3 ext. headers has valid qfi",
+			mode, qfiULMatchingProvisioned, qfiDLInsertionProvisioned, false, 3)
+		describePDUSessContExtHdrQFI2("1 ext. header has invalid qfi",
+			mode, qfiULMatchingProvisioned, qfiDLInsertionProvisioned, true, 1)
+		describePDUSessContExtHdrQFI2("3 ext. headres has invalid qfi",
+			mode, qfiULMatchingProvisioned, qfiDLInsertionProvisioned, true, 3)
+		describePDUSessContExtHdrQFI2("no ext. headers",
+			mode, qfiULMatchingProvisioned, qfiDLInsertionProvisioned, false, 0)
+	})
+
+}
+
+func describePDUSessContExtHdrQFI2(
+	title string, mode framework.UPGIPMode,
+	qfiULMatchingProvisioned bool,
+	qfiDLInsertionProvisioned bool,
+	useInvalidQfi bool,
+	nExtHdrs uint,
+) {
+	var qfi uint8 = 5
+	var qfiUL uint8 = qfi
+	if useInvalidQfi {
+		qfiUL = qfi + 1
+	}
+
+	ginkgo.Context(title, func() {
+		f := framework.NewDefaultFramework(framework.UPGModePGW, mode)
+
+		f.TPDUHook = func(tpdu *gtpumessage.TPDU, fromPGW bool) {
+			defer ginkgo.GinkgoRecover()
+			if fromPGW && !qfiDLInsertionProvisioned {
+				// ext flag must be reset
+				framework.ExpectEqual((tpdu.Header.Flags>>2)&1, uint8(0))
+				return
+			}
+			if fromPGW && qfiDLInsertionProvisioned {
+				// ext flag should contain only the PDU
+				// extension bit
+				framework.ExpectEqual(
+					(tpdu.Header.Flags)&(7<<0),
+					uint8(1<<2))
+
+				// Payload[0:4] contains SQN, N-PDU number next
+				// ext. hdr. type. Rest of payload contains
+				// ext. headers
+				framework.ExpectEqual(
+					tpdu.Payload[3:8],
+					[]byte{
+						0x85, // next extension type (PDU Session Container)
+						1,    // ext header length
+						0,    // PDU CONT TYPE DL
+						qfi,  // ext content
+						0,    // No more ext. headers
+					})
+
+				// Strip the extension header
+				tpdu.Payload = tpdu.Payload[8:]
+				return
+			}
+
+			// Add an extension to T-PDU
+			// GTP library doesn't support extensions, so some hacks are needed
+			// TODO: fix the library
+			prepend := []byte{
+				0, // seq number hi (unused)
+				0, // seq number lo (unused)
+				0, // N-PDU number (unused)
+			}
+
+			if nExtHdrs > 0 {
+				extHdr := []byte{
+					0x85,   // next extension type (PDU Session Container)
+					1,      // ext header length
+					1 << 4, // PDU CONT TYPE UL
+					qfiUL,  // ext content: QFI
+				}
+				prepend = append(prepend, extHdr...)
+			}
+
+			for i := 1; i < int(nExtHdrs); i++ {
+				extHdr := []byte{
+					0x32, // next extension type
+					1,    // ext header length
+					0,    // ext content
+					0xff, // ext content
+				}
+				prepend = append(prepend, extHdr...)
+			}
+			prepend = append(prepend, 0) // next ext type: no extension
+
+			tpdu.Header.Flags |= 4
+			tpdu.Payload = append(prepend, tpdu.Payload...)
+		}
+
+		ginkgo.BeforeEach(func() {
+			ginkgo.By("Establishing a session")
+			cfg := framework.SessionConfig{}
+			cfg.IdBase = 1
+			cfg.UEIP = f.UEIP()
+			cfg.Mode = f.Mode
+			cfg.TEIDPGWs5u = framework.TEIDPGWs5u
+			cfg.TEIDSGWs5u = framework.TEIDSGWs5u
+			cfg.PGWIP = f.VPPCfg.GetVPPAddress("grx").IP
+			cfg.SGWIP = f.VPPCfg.GetNamespaceAddress("grx").IP
+			cfg.SkipSDFFilter = true
+
+			ieMatchQFI := ie.NewQFI(qfi)
+			ieQERID := ie.NewQERID(1)
+			ies := cfg.SessionIEs()
+			for _, pdr := range ies {
+				if pdr.Type != ie.CreatePDR {
+					continue
+				}
+				_, err := pdr.FindByType(ie.OuterHeaderRemoval)
+				if errors.Is(err, ie.ErrIENotFound) {
+					// This pdr is a DL pdr
+					if !qfiDLInsertionProvisioned {
+						continue
+					}
+					pdr.Add(ieQERID)
+				} else {
+					// This pdr is an UL pdr
+					if !qfiULMatchingProvisioned {
+						continue
+					}
+					framework.ExpectNoError(err)
+					pdi, err := pdr.FindByType(ie.PDI)
+					framework.ExpectNoError(err)
+					pdi.Add(ieMatchQFI)
+					pdr.Remove(ie.PDI)
+					pdr.Add(pdi)
+				}
+			}
+			if qfiDLInsertionProvisioned {
+				ies = append(ies, ie.NewCreateQER(
+					ieQERID, ie.NewGateStatus(0, 0),
+					ieMatchQFI))
+			}
+			_, err := f.PFCP.EstablishSession(f.Context, 0, ies...)
+			framework.ExpectNoError(err)
+		})
+
+		expect := framework.ExpectError
+		if qfiULMatchingProvisioned && nExtHdrs > 0 && !useInvalidQfi {
+			expect = framework.ExpectNoError
+		} else if !qfiULMatchingProvisioned {
+			expect = framework.ExpectNoError
+		}
+
+		ginkgo.It("in DL direction", func() {
+			tg, clientNS, serverNS := newReverseTrafficGen(
+				f, &traffic.HTTPConfig{}, &traffic.SimpleTrafficRec{})
+			expect(tg.Run(f.Context, clientNS, serverNS))
+		})
+
+		ginkgo.It("in UL direction", func() {
+			tg, clientNS, serverNS := newTrafficGen(
+				f, &traffic.HTTPConfig{}, &traffic.SimpleTrafficRec{})
+			expect(tg.Run(f.Context, clientNS, serverNS))
+		})
+	})
+}
+
 var _ = ginkgo.Describe("CLI debug commands", func() {
 	f := framework.NewDefaultFramework(framework.UPGModeTDF, framework.UPGIPModeV4)
 	ginkgo.Context("show upf session", func() {
@@ -2547,6 +2734,23 @@ func newTrafficGen(f *framework.Framework, cfg traffic.TrafficConfig, rec traffi
 	return traffic.NewTrafficGen(cfg, rec), clientNS, serverNS
 }
 
+func newReverseTrafficGen(f *framework.Framework, cfg traffic.TrafficConfig, rec traffic.TrafficRec) (*traffic.TrafficGen, *network.NetNS, *network.NetNS) {
+	ginkgo.By("starting the reverse traffic generator")
+	// Here, UE is the server
+	cfg.SetNoLinger(true)
+	if !cfg.HasServerIP() {
+		cfg.AddServerIP(f.UEIP())
+	}
+	serverNS := f.VPP.GetNS("ue")
+	var clientNS *network.NetNS
+	if f.Mode == framework.UPGModeGTPProxy {
+		clientNS = f.VPP.GetNS("srv")
+	} else {
+		clientNS = f.VPP.GetNS("sgi")
+	}
+	return traffic.NewTrafficGen(cfg, rec), clientNS, serverNS
+}
+
 func runTrafficGen(f *framework.Framework, cfg traffic.TrafficConfig, rec traffic.TrafficRec) {
 	tg, clientNS, serverNS := newTrafficGen(f, cfg, rec)
 	framework.ExpectNoError(tg.Run(f.Context, clientNS, serverNS))
diff --git a/upf/pfcp.c b/upf/pfcp.c
index 96c699c..566c0a2 100644
--- a/upf/pfcp.c
+++ b/upf/pfcp.c
@@ -5081,6 +5081,7 @@ static struct pfcp_group_ie_def pfcp_pdi_group[] =
     },
     [PDI_QFI] = {
       .type = PFCP_IE_QFI,
+      .is_array = true,
       .offset = offsetof(pfcp_ie_pdi_t, qfi)
     },
     [PDI_FRAMED_ROUTE] = {
diff --git a/upf/pfcp.h b/upf/pfcp.h
index 899674f..f9a7382 100644
--- a/upf/pfcp.h
+++ b/upf/pfcp.h
@@ -1377,7 +1377,7 @@ typedef struct
   pfcp_ie_application_id_t application_id;
   pfcp_ie_ethernet_pdu_session_information_t ethernet_pdu_session_information;
   pfcp_ie_ethernet_packet_filter_t ethernet_packet_filter;
-  pfcp_ie_qfi_t qfi;
+  pfcp_ie_qfi_t *qfi;
   pfcp_ie_framed_route_t *framed_route;
   pfcp_ie_framed_routing_t framed_routing;
   pfcp_ie_framed_ipv6_route_t *framed_ipv6_route;
diff --git a/upf/upf.h b/upf/upf.h
index 1d38d9e..3a02302 100644
--- a/upf/upf.h
+++ b/upf/upf.h
@@ -106,6 +106,22 @@ typedef CLIB_PACKED (struct
 }) gtpu_ext_header_t;
 /* clang-format on */
 
+#define GTPU_EXT_H_TYPE_PDU_CONT 0x85
+
+/* *clang-format off* */
+typedef CLIB_PACKED (struct
+{
+  u8 len;
+#define GTPU_PDU_CONT_TYPE_MASK ((1<<4 - 1) << 4)
+#define GTPU_PDU_CONT_TYPE_DL 0
+#define GTPU_PDU_CONT_TYPE_UL (1<<4)
+  u8 pdu_type;
+#define GTPU_PDU_CONT_QFI_MASK ((1<<6) - 1)
+  u8 qfi;
+  u8 next_ext_type;
+}) gtpu_ext_pdu_container_t;
+/* *clang-format on* */
+
 /* clang-format off */
 typedef CLIB_PACKED (struct
 {
@@ -360,6 +376,7 @@ typedef struct
 
   u32 fib_index;
   u32 teid;             // TEID
+  u8 qfi;
   ip46_address_t ue_ip; // UE-IP
 
   /* SDF */
@@ -389,6 +406,9 @@ typedef struct
 
   pfcp_ie_f_teid_t teid;
   pfcp_ie_ue_ip_address_t ue_addr;
+  /* Array of allowed QFI's. If non-empty, GTPU packet's QFI must match one of
+     the elemets. */
+  u8 *qfis;
   acl_rule_t *acl;
   adr_rule_t adr;
 } upf_pdi_t;
@@ -658,6 +678,7 @@ typedef struct
   u8 gate_status[UPF_DIRECTION_MAX];
 
   pfcp_ie_mbr_t mbr;
+  u8 qfi;
   clib_bihash_kv_8_8_t policer;
 } upf_qer_t;
 
diff --git a/upf/upf_buffer_opaque.h b/upf/upf_buffer_opaque.h
index a7a5475..d50872c 100644
--- a/upf/upf_buffer_opaque.h
+++ b/upf/upf_buffer_opaque.h
@@ -26,18 +26,28 @@ typedef struct
 {
   struct
   {
-    u64 pad[1];
     u32 teid;
     u32 session_index;
     u16 ext_hdr_len;
     u16 data_offset; /* offset relative to ip hdr */
     u8 hdr_flags;
+    /* qfi_hdr_present: GTPU decap node sets this field to 1 if PDU extension
+       header is present. GTPU encap node uses this information in order to
+       insert a PDU ext. hdr. if required and if not yet present. */
+    u8 qfi_hdr_present:1;
+    /* qfi_present: Set, if GTPU encap should insert a QFI. */
+    u8 qfi_present:1;
+    /* qfi: GTPU decap node sets this field to GTPU QFI from PDU extension
+       header. UPF forward node sets this field to QER's QFI, if any. GTPU
+       encap node uses this field to set PDU ext. hdr. QFI field. */
+    u8 qfi:6;
     u8 flags;
     u8 flow_key_direction : 1; // flow_direction_op_t
     u8 direction : 1;          // flow_direction_t
     u8 is_proxied : 1;
     u32 pdr_idx;
     u32 flow_id;
+    u64 pad[1];
   } gtpu;
 } upf_buffer_opaque_t;
 
@@ -65,6 +75,9 @@ STATIC_ASSERT (sizeof (upf_buffer_opaque_t) <=
       clib_memset (upf_buffer_opaque (b), 0, sizeof (upf_buffer_opaque_t));   \
       b->flags |= UPF_BUFFER_F_GTPU_INITIALIZED;                              \
       upf_buffer_opaque (b)->gtpu.session_index = sidx;                       \
+      upf_buffer_opaque (b)->gtpu.qfi_hdr_present = 0;                        \
+      upf_buffer_opaque (b)->gtpu.qfi_present = 0;                            \
+      upf_buffer_opaque (b)->gtpu.qfi = ~0;                                   \
       upf_buffer_opaque (b)->gtpu.flags =                                     \
         is_ip4 ? BUFFER_GTP_UDP_IP4 : BUFFER_GTP_UDP_IP6;                     \
     }                                                                         \
@@ -79,6 +92,9 @@ STATIC_ASSERT (sizeof (upf_buffer_opaque_t) <=
     {                                                                         \
       clib_memset (upf_buffer_opaque (b), 0, sizeof (upf_buffer_opaque_t));   \
       upf_buffer_opaque (b)->gtpu.session_index = sidx;                       \
+      upf_buffer_opaque (b)->gtpu.qfi_hdr_present = 0;                        \
+      upf_buffer_opaque (b)->gtpu.qfi_present = 0;                            \
+      upf_buffer_opaque (b)->gtpu.qfi = ~0;                                   \
       upf_buffer_opaque (b)->gtpu.flags =                                     \
         is_ip4 ? BUFFER_GTP_UDP_IP4 : BUFFER_GTP_UDP_IP6;                     \
     }                                                                         \
diff --git a/upf/upf_classify.c b/upf/upf_classify.c
index b2e10a6..8f43816 100644
--- a/upf/upf_classify.c
+++ b/upf/upf_classify.c
@@ -140,7 +140,7 @@ acl_port_in_range (const u16 port, upf_acl_t *acl, int field)
 }
 
 always_inline int
-upf_acl_classify_one (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
+upf_acl_classify_one (vlib_main_t *vm, u32 teid, flow_entry_t *flow, u8 qfi,
                       flow_direction_t direction, u8 is_ip4, upf_acl_t *acl,
                       struct rules *active)
 {
@@ -157,6 +157,8 @@ upf_acl_classify_one (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
       if (teid != acl->teid)
         return 0;
     }
+  if (acl->qfi != (u8)~0 && qfi != acl->qfi)
+    return 0;
 
   switch (acl->match_ue_ip)
     {
@@ -221,7 +223,7 @@ upf_acl_classify_one (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
 }
 
 always_inline u32
-upf_acl_classify_forward (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
+upf_acl_classify_forward (vlib_main_t *vm, u32 teid, u8 qfi, flow_entry_t *flow,
                           struct rules *active, u8 is_ip4, u32 *pdr_idx)
 {
   u32 next = UPF_CLASSIFY_NEXT_DROP;
@@ -269,7 +271,7 @@ upf_acl_classify_forward (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
   vec_foreach (acl, acl_vec)
     {
       upf_debug ("%d forward acl pdr %d", acl - acl_vec, acl->pdr_idx);
-      if (upf_acl_classify_one (vm, teid, flow, FT_ORIGIN, is_ip4, acl,
+      if (upf_acl_classify_one (vm, teid, flow, qfi, FT_ORIGIN, is_ip4, acl,
                                 active))
         {
           upf_pdr_t *pdr;
@@ -329,7 +331,7 @@ upf_acl_classify_forward (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
 
 /* Classify traffic from the proxy towards the UE */
 always_inline u32
-upf_acl_classify_proxied (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
+upf_acl_classify_proxied (vlib_main_t *vm, u32 teid, u8 qfi, flow_entry_t *flow,
                           struct rules *active, u8 is_ip4, u32 *pdr_idx)
 {
   u32 next = UPF_CLASSIFY_NEXT_DROP;
@@ -347,7 +349,7 @@ upf_acl_classify_proxied (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
   vec_foreach (acl, acl_vec)
     {
       upf_debug ("%d proxied acl pdr %d", acl - acl_vec, acl->pdr_idx);
-      if (upf_acl_classify_one (vm, teid, flow, FT_REVERSE, is_ip4, acl,
+      if (upf_acl_classify_one (vm, teid, flow, qfi, FT_REVERSE, is_ip4, acl,
                                 active))
         {
           upf_pdr_t *pdr;
@@ -376,7 +378,7 @@ upf_acl_classify_proxied (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
 }
 
 always_inline u32
-upf_acl_classify_return (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
+upf_acl_classify_return (vlib_main_t *vm, u32 teid, u8 qfi, flow_entry_t *flow,
                          struct rules *active, u8 is_ip4, u32 *pdr_idx)
 {
   u32 next = UPF_CLASSIFY_NEXT_DROP;
@@ -394,7 +396,7 @@ upf_acl_classify_return (vlib_main_t *vm, u32 teid, flow_entry_t *flow,
   vec_foreach (acl, acl_vec)
     {
       upf_debug ("%d return acl pdr %d", acl - acl_vec, acl->pdr_idx);
-      if (upf_acl_classify_one (vm, teid, flow, FT_REVERSE, is_ip4, acl,
+      if (upf_acl_classify_one (vm, teid, flow, qfi, FT_REVERSE, is_ip4, acl,
                                 active))
         {
           upf_pdr_t *pdr;
@@ -454,6 +456,7 @@ upf_classify_fn (vlib_main_t *vm, vlib_node_runtime_t *node,
       u32 n_left_to_next;
       vlib_buffer_t *b;
       flow_entry_t *flow;
+      u8 qfi = ~0;
       flow_direction_t direction;
       u32 bi;
       u8 reclassify_proxy_flow;
@@ -501,6 +504,9 @@ upf_classify_fn (vlib_main_t *vm, vlib_node_runtime_t *node,
                        "FTD_OP_FLIP",
                      direction == FT_ORIGIN ? "FT_ORIGIN" : "FT_REVERSE");
 
+          if (upf_buffer_opaque (b)->gtpu.qfi_hdr_present)
+            qfi = upf_buffer_opaque (b)->gtpu.qfi;
+
           if (flow_side (flow, direction)->next != FT_NEXT_CLASSIFY)
             {
               /* we shouldn't be here, this can happend when multiple
@@ -519,27 +525,27 @@ upf_classify_fn (vlib_main_t *vm, vlib_node_runtime_t *node,
           else if (direction == FT_ORIGIN)
             {
               next = upf_acl_classify_forward (
-                vm, upf_buffer_opaque (b)->gtpu.teid, flow, active, is_ip4,
+                vm, upf_buffer_opaque (b)->gtpu.teid, qfi, flow, active, is_ip4,
                 &upf_buffer_opaque (b)->gtpu.pdr_idx);
               if (reclassify_proxy_flow) /* for app detection */
                 {
                   if (upf_buffer_opaque (b)->gtpu.is_proxied)
-                    upf_acl_classify_proxied (vm, 0, flow, active, is_ip4, 0);
+                    upf_acl_classify_proxied (vm, 0, ~0, flow, active, is_ip4, 0);
                   else
-                    upf_acl_classify_return (vm, 0, flow, active, is_ip4, 0);
+                    upf_acl_classify_return (vm, 0, ~0, flow, active, is_ip4, 0);
                 }
             }
           else
             {
               if (reclassify_proxy_flow) /* for app detection */
-                upf_acl_classify_forward (vm, 0, flow, active, is_ip4, 0);
+                upf_acl_classify_forward (vm, 0, ~0, flow, active, is_ip4, 0);
               if (upf_buffer_opaque (b)->gtpu.is_proxied)
                 next = upf_acl_classify_proxied (
-                  vm, upf_buffer_opaque (b)->gtpu.teid, flow, active, is_ip4,
+                  vm, upf_buffer_opaque (b)->gtpu.teid, qfi, flow, active, is_ip4,
                   &upf_buffer_opaque (b)->gtpu.pdr_idx);
               else
                 next = upf_acl_classify_return (
-                  vm, upf_buffer_opaque (b)->gtpu.teid, flow, active, is_ip4,
+                  vm, upf_buffer_opaque (b)->gtpu.teid, qfi, flow, active, is_ip4,
                   &upf_buffer_opaque (b)->gtpu.pdr_idx);
             }
 
diff --git a/upf/upf_gtpu_decap.c b/upf/upf_gtpu_decap.c
index bbb02da..d043ab7 100644
--- a/upf/upf_gtpu_decap.c
+++ b/upf/upf_gtpu_decap.c
@@ -48,6 +48,7 @@ typedef struct
   u32 session_index;
   u32 error;
   u32 teid;
+  u8 qfi;
 } gtpu_rx_trace_t;
 
 static u8 *
@@ -68,8 +69,8 @@ format_gtpu_rx_trace (u8 *s, va_list *args)
   else if (t->session_index != ~0)
     {
       s = format (
-        s, "GTPU decap from gtpu_session%d teid 0x%08x next %d error %d",
-        t->session_index, t->teid, t->next_index, t->error);
+        s, "GTPU decap from gtpu_session%d teid 0x%08x qfi %d next %d error %d",
+        t->session_index, t->teid, t->qfi, t->next_index, t->error);
     }
   else
     {
@@ -103,6 +104,90 @@ upf_gtpu_signalling_msg (gtpu_header_t *gtpu, u32 *error)
     }
 }
 
+static bool
+upf_gtpu_handle_ext_hdrs_slow (gtpu_ext_header_t * ext, u8 *buffer_end,
+			       u32 *gtpu_hdr_len);
+
+/* Return the whole gtpu header length in *GTPU_HDR_LEN and the QoS Flow
+   Identifier in *QFI. Set *QFI to ~0 if QFI isn't specified in ext.
+   headers.
+
+   If we have an invalid ext. header length or if we overflow the buffer
+   according to BUFFER_END, return false. In this case, modify *QFI and
+   *GTPU_HDR_LEN to invalid values. Otherwise, if the gtpu ext. headers have
+   valid lengths, return true. */
+static inline bool
+upf_gtpu_handle_ext_hdrs (gtpu_header_t * gtpu, u8 *buffer_end,
+			  u32 *gtpu_hdr_len, u8 *qfi)
+{
+  *qfi = ~0;
+  *gtpu_hdr_len = sizeof (gtpu_header_t) - 4;
+
+  if (PREDICT_TRUE ((gtpu->ver_flags & GTPU_E_S_PN_BIT) == 0))
+    return (u8 *)gtpu + *gtpu_hdr_len < buffer_end;
+
+  *gtpu_hdr_len = sizeof (gtpu_header_t);
+
+  if (PREDICT_FALSE (gtpu->ver_flags & GTPU_E_BIT) == 0)
+    return (u8 *)gtpu + *gtpu_hdr_len < buffer_end;
+
+  /* TS 29.281 - 5.2.2 Extension Header types (20)
+
+     NOTE 4: For a GTP-PDU with several Extension Headers, the PDU Session
+     Container should be the first Extension Header.
+
+     Here we implement a fast path for the case of a single extension header of
+     type PDU Session Container. */
+  gtpu_ext_pdu_container_t *ext_hdr =
+    (gtpu_ext_pdu_container_t *) (gtpu + 1);
+  gtpu_ext_header_t *next_ext_hdr;
+
+  if (PREDICT_TRUE ((u8 *)(ext_hdr + 1) <= buffer_end &&
+		    gtpu->next_ext_type == GTPU_EXT_H_TYPE_PDU_CONT))
+    {
+      if (PREDICT_FALSE (ext_hdr->len != 1))
+	return false;
+
+      *gtpu_hdr_len += 4;
+      *qfi = ext_hdr->qfi & GTPU_PDU_CONT_QFI_MASK;
+
+      if (PREDICT_TRUE (ext_hdr->next_ext_type == 0))
+	return true;
+
+      next_ext_hdr = (void *)&ext_hdr->next_ext_type;
+    }
+  else
+    {
+      next_ext_hdr = (void *)&gtpu->next_ext_type;
+    }
+
+  return upf_gtpu_handle_ext_hdrs_slow(next_ext_hdr, buffer_end, gtpu_hdr_len);
+}
+
+static bool
+upf_gtpu_handle_ext_hdrs_slow (gtpu_ext_header_t * ext, u8 *buffer_end,
+			       u32 *gtpu_hdr_len)
+{
+  while (1)
+    {
+      if ((u8 *)ext >= buffer_end)
+	return false;
+
+      if (ext->type == 0)
+	return true;
+
+      if ((u8 *)&ext->len >= buffer_end)
+	return false;
+
+      if (ext->len == 0)
+	return false;
+
+      /* gtpu_ext_header_t is 4 bytes and the len is in units of 4 */
+      *gtpu_hdr_len += ext->len * 4;
+      ext += ext->len * 4 / sizeof (*ext);
+    }
+}
+
 always_inline uword
 upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
                 vlib_frame_t *from_frame, u8 is_ip4)
@@ -139,6 +224,7 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
           ip6_header_t *ip6_0, *ip6_1;
           gtpu_header_t *gtpu0, *gtpu1;
           u32 gtpu_hdr_len0 = 0, gtpu_hdr_len1 = 0;
+          u8 qfi0 = ~0, qfi1 = ~0;
           u32 session_index0, session_index1;
           u32 rule_index0, rule_index1;
           upf_session_t *t0, *t1;
@@ -315,35 +401,12 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
 
         next0:
           /* Manipulate gtpu header */
-          if (PREDICT_FALSE ((gtpu0->ver_flags & GTPU_E_S_PN_BIT) != 0))
-            {
-              gtpu_hdr_len0 = sizeof (gtpu_header_t);
-
-              if (PREDICT_FALSE ((gtpu0->ver_flags & GTPU_E_BIT) != 0))
-                {
-                  gtpu_ext_header_t *ext =
-                    (gtpu_ext_header_t *) &gtpu0->next_ext_type;
-                  u8 *end = vlib_buffer_get_tail (b0);
-
-                  while ((u8 *) ext < end && ext->type != 0)
-                    {
-                      if (PREDICT_FALSE (!ext->len))
-                        {
-                          error0 = UPF_GTPU_ERROR_LENGTH_ERROR;
-                          next0 = UPF_GTPU_INPUT_NEXT_DROP;
-                          goto trace0;
-                        }
-
-                      /* gtpu_ext_header_t is 4 bytes and the len is in units
-                       * of 4 */
-                      gtpu_hdr_len0 += ext->len * 4;
-                      ext += ext->len * 4 / sizeof (*ext);
-                    }
-                }
-            }
-          else
+          if (!upf_gtpu_handle_ext_hdrs(gtpu0, vlib_buffer_get_tail (b0),
+                                        &gtpu_hdr_len0, &qfi0))
             {
-              gtpu_hdr_len0 = sizeof (gtpu_header_t) - 4;
+              error0 = UPF_GTPU_ERROR_LENGTH_ERROR;
+              next0 = UPF_GTPU_INPUT_NEXT_DROP;
+              goto trace0;
             }
 
           hdr_len0 += gtpu_hdr_len0;
@@ -354,6 +417,8 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
           upf_buffer_opaque (b0)->gtpu.hdr_flags = gtpu0->ver_flags;
           upf_buffer_opaque (b0)->gtpu.teid =
             clib_net_to_host_u32 (gtpu0->teid);
+	  upf_buffer_opaque (b0)->gtpu.qfi_hdr_present = qfi0 != (u8)~0;
+	  upf_buffer_opaque (b0)->gtpu.qfi = qfi0;
           upf_buffer_opaque (b0)->gtpu.pdr_idx =
             !(pfcp_get_rules (t0, PFCP_ACTIVE)->flags & PFCP_CLASSIFY) ?
               rule_index0 :
@@ -392,6 +457,7 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
               tr->error = error0;
               tr->session_index = session_index0;
               tr->teid = clib_net_to_host_u32 (gtpu0->teid);
+              tr->qfi = qfi0;
             }
 
           if (PREDICT_FALSE ((gtpu1->ver_flags & GTPU_VER_MASK) !=
@@ -501,35 +567,12 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
 
         next1:
           /* Manipulate gtpu header */
-          if (PREDICT_FALSE ((gtpu1->ver_flags & GTPU_E_S_PN_BIT) != 0))
-            {
-              gtpu_hdr_len1 = sizeof (gtpu_header_t);
-
-              if (PREDICT_FALSE ((gtpu1->ver_flags & GTPU_E_BIT) != 0))
-                {
-                  gtpu_ext_header_t *ext =
-                    (gtpu_ext_header_t *) &gtpu1->next_ext_type;
-                  u8 *end = vlib_buffer_get_tail (b1);
-
-                  while ((u8 *) ext < end && ext->type != 0)
-                    {
-                      if (PREDICT_FALSE (!ext->len))
-                        {
-                          error1 = UPF_GTPU_ERROR_LENGTH_ERROR;
-                          next1 = UPF_GTPU_INPUT_NEXT_DROP;
-                          goto trace1;
-                        }
-
-                      /* gtpu_ext_header_t is 4 bytes and the len is in units
-                       * of 4 */
-                      gtpu_hdr_len1 += ext->len * 4;
-                      ext += ext->len * 4 / sizeof (*ext);
-                    }
-                }
-            }
-          else
+          if (!upf_gtpu_handle_ext_hdrs(gtpu1, vlib_buffer_get_tail (b1),
+                                        &gtpu_hdr_len1, &qfi1))
             {
-              gtpu_hdr_len1 = sizeof (gtpu_header_t) - 4;
+              error1 = UPF_GTPU_ERROR_LENGTH_ERROR;
+              next1 = UPF_GTPU_INPUT_NEXT_DROP;
+              goto trace1;
             }
 
           hdr_len1 += gtpu_hdr_len1;
@@ -540,6 +583,8 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
           upf_buffer_opaque (b1)->gtpu.hdr_flags = gtpu1->ver_flags;
           upf_buffer_opaque (b1)->gtpu.teid =
             clib_net_to_host_u32 (gtpu1->teid);
+	  upf_buffer_opaque (b1)->gtpu.qfi_hdr_present = qfi1 != (u8)~0;
+	  upf_buffer_opaque (b1)->gtpu.qfi = qfi1;
           upf_buffer_opaque (b1)->gtpu.pdr_idx =
             !(pfcp_get_rules (t1, PFCP_ACTIVE)->flags & PFCP_CLASSIFY) ?
               rule_index1 :
@@ -578,6 +623,7 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
               tr->error = error1;
               tr->session_index = session_index1;
               tr->teid = clib_net_to_host_u32 (gtpu1->teid);
+              tr->qfi = qfi1;
             }
 
           vlib_validate_buffer_enqueue_x2 (vm, node, next_index, to_next,
@@ -594,6 +640,7 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
           ip6_header_t *ip6_0;
           gtpu_header_t *gtpu0;
           u32 gtpu_hdr_len0 = 0;
+          u8 qfi0 = ~0;
           u32 session_index0;
           u32 rule_index0;
           upf_session_t *t0;
@@ -739,35 +786,12 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
 
         next00:
           /* Manipulate gtpu header */
-          if (PREDICT_FALSE ((gtpu0->ver_flags & GTPU_E_S_PN_BIT) != 0))
-            {
-              gtpu_hdr_len0 = sizeof (gtpu_header_t);
-
-              if (PREDICT_FALSE ((gtpu0->ver_flags & GTPU_E_BIT) != 0))
-                {
-                  gtpu_ext_header_t *ext =
-                    (gtpu_ext_header_t *) &gtpu0->next_ext_type;
-                  u8 *end = vlib_buffer_get_tail (b0);
-
-                  while ((u8 *) ext < end && ext->type != 0)
-                    {
-                      if (PREDICT_FALSE (!ext->len))
-                        {
-                          error0 = UPF_GTPU_ERROR_LENGTH_ERROR;
-                          next0 = UPF_GTPU_INPUT_NEXT_DROP;
-                          goto trace00;
-                        }
-
-                      /* gtpu_ext_header_t is 4 bytes and the len is in units
-                       * of 4 */
-                      gtpu_hdr_len0 += ext->len * 4;
-                      ext += ext->len * 4 / sizeof (*ext);
-                    }
-                }
-            }
-          else
+          if (!upf_gtpu_handle_ext_hdrs(gtpu0, vlib_buffer_get_tail (b0),
+                                        &gtpu_hdr_len0, &qfi0))
             {
-              gtpu_hdr_len0 = sizeof (gtpu_header_t) - 4;
+              error0 = UPF_GTPU_ERROR_LENGTH_ERROR;
+              next0 = UPF_GTPU_INPUT_NEXT_DROP;
+              goto trace00;
             }
 
           hdr_len0 += gtpu_hdr_len0;
@@ -778,6 +802,8 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
           upf_buffer_opaque (b0)->gtpu.hdr_flags = gtpu0->ver_flags;
           upf_buffer_opaque (b0)->gtpu.teid =
             clib_net_to_host_u32 (gtpu0->teid);
+	  upf_buffer_opaque (b0)->gtpu.qfi_hdr_present = qfi0 != (u8)~0;
+	  upf_buffer_opaque (b0)->gtpu.qfi = qfi0;
           upf_buffer_opaque (b0)->gtpu.pdr_idx =
             !(pfcp_get_rules (t0, PFCP_ACTIVE)->flags & PFCP_CLASSIFY) ?
               rule_index0 :
@@ -816,6 +842,7 @@ upf_gtpu_input (vlib_main_t *vm, vlib_node_runtime_t *node,
               tr->error = error0;
               tr->session_index = session_index0;
               tr->teid = clib_net_to_host_u32 (gtpu0->teid);
+              tr->qfi = qfi0;
             }
 
           vlib_validate_buffer_enqueue_x1 (vm, node, next_index, to_next,
diff --git a/upf/upf_gtpu_encap.c b/upf/upf_gtpu_encap.c
index 443a9ad..e05c50f 100644
--- a/upf/upf_gtpu_encap.c
+++ b/upf/upf_gtpu_encap.c
@@ -417,6 +417,48 @@ upf_gtpu_end_marker (u32 fib_index, u32 dpoi_index, u8 *rewrite, int is_ip4)
 
 #define foreach_fixed_header6_offset _ (0) _ (1) _ (2) _ (3) _ (4) _ (5) _ (6)
 
+always_inline void
+advance_for_qfi (vlib_buffer_t *b)
+{
+  if (!upf_buffer_opaque (b)->gtpu.qfi_present ||
+      upf_buffer_opaque (b)->gtpu.qfi_hdr_present)
+    return;
+
+  /* Add space for the extension header that contains QFI, if the header isn't
+     present already */
+  vlib_buffer_advance(b, -sizeof(gtpu_ext_pdu_container_t));
+
+  /* Add space for the SQN, N-PDU number and ext. header type if not already
+     present */
+  if (!(upf_buffer_opaque (b)->gtpu.hdr_flags & GTPU_E_S_PN_BIT))
+    vlib_buffer_advance (b, -4);
+}
+
+always_inline void
+write_qfi (gtpu_header_t *gtpu, vlib_buffer_t *b)
+{
+  gtpu_ext_pdu_container_t *ext_hdr = (void *)(gtpu + 1);
+
+  if (!upf_buffer_opaque (b)->gtpu.qfi_present)
+    return;
+
+  ext_hdr->qfi = upf_buffer_opaque (b)->gtpu.qfi;
+  if (upf_buffer_opaque (b)->gtpu.qfi_hdr_present)
+    return;
+  /* Write the static part of the ext. header containing QFI, if the ext.
+     header wasn't present originally */
+  gtpu->ver_flags &= ~GTPU_E_S_PN_BIT;
+  gtpu->ver_flags |= GTPU_E_BIT;
+  gtpu->sequence = 0;
+  gtpu->pdu_number = 0;
+  gtpu->next_ext_type = GTPU_EXT_H_TYPE_PDU_CONT;
+  ext_hdr->len = 1;
+  ext_hdr->pdu_type = GTPU_PDU_CONT_TYPE_DL;
+  /* Write the next ext. header type if this field wasn't present originally */
+  if (!(upf_buffer_opaque (b)->gtpu.hdr_flags & GTPU_E_S_PN_BIT))
+    ext_hdr->next_ext_type = 0;
+}
+
 always_inline uword
 upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
                   vlib_frame_t *from_frame, u32 is_ip4)
@@ -432,6 +474,7 @@ upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
   upf_far_t *far0 = NULL, *far1 = NULL, *far2 = NULL, *far3 = NULL;
   upf_peer_t *peer0 = NULL, *peer1 = NULL, *peer2 = NULL, *peer3 = NULL;
 
+  int const ip_hdr_size = is_ip4 ? sizeof(ip4_header_t) : sizeof(ip6_header_t);
   u32 const csum_mask =
     (VNET_BUFFER_OFFLOAD_F_TCP_CKSUM | VNET_BUFFER_OFFLOAD_F_UDP_CKSUM |
      (is_ip4 ? VNET_BUFFER_OFFLOAD_F_IP_CKSUM : 0));
@@ -574,6 +617,12 @@ upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
             vlib_buffer_advance (b3,
                                  -upf_buffer_opaque (b3)->gtpu.ext_hdr_len);
 
+	  /* If necessary, add space for GTPU PDU container ext. hdr. */
+	  advance_for_qfi (b0);
+	  advance_for_qfi (b1);
+	  advance_for_qfi (b2);
+	  advance_for_qfi (b3);
+
           /* Apply the rewrite string. $$$$ vnet_rewrite? */
           vlib_buffer_advance (b0, -(word) _vec_len (far0->forward.rewrite));
           vlib_buffer_advance (b1, -(word) _vec_len (far1->forward.rewrite));
@@ -654,62 +703,21 @@ upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
               ip4_3->checksum = ip_csum_fold (sum3);
               ip4_3->length = new_l3;
 
-              /* Fix UDP length and set source port */
               udp0 = (udp_header_t *) (ip4_0 + 1);
-              new_l0 = clib_host_to_net_u16 (
+              udp0->length = clib_host_to_net_u16 (
                 vlib_buffer_length_in_chain (vm, b0) - sizeof (*ip4_0));
-              udp0->length = new_l0;
-              udp0->src_port = flow_hash0;
               udp1 = (udp_header_t *) (ip4_1 + 1);
-              new_l1 = clib_host_to_net_u16 (
+              udp1->length = clib_host_to_net_u16 (
                 vlib_buffer_length_in_chain (vm, b1) - sizeof (*ip4_1));
-              udp1->length = new_l1;
-              udp1->src_port = flow_hash1;
               udp2 = (udp_header_t *) (ip4_2 + 1);
-              new_l2 = clib_host_to_net_u16 (
+              udp2->length = clib_host_to_net_u16 (
                 vlib_buffer_length_in_chain (vm, b2) - sizeof (*ip4_2));
-              udp2->length = new_l2;
-              udp2->src_port = flow_hash2;
               udp3 = (udp_header_t *) (ip4_3 + 1);
-              new_l3 = clib_host_to_net_u16 (
+              udp3->length = clib_host_to_net_u16 (
                 vlib_buffer_length_in_chain (vm, b3) - sizeof (*ip4_3));
-              udp3->length = new_l3;
-              udp3->src_port = flow_hash3;
-
-              /* Fix GTPU length */
-              gtpu0 = (gtpu_header_t *) (udp0 + 1);
-              new_l0 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b0) - sizeof (*ip4_0) -
-                sizeof (*udp0) - GTPU_V1_HDR_LEN);
-              gtpu0->length = new_l0;
-              gtpu0->ver_flags |=
-                (upf_buffer_opaque (b0)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
-              gtpu1 = (gtpu_header_t *) (udp1 + 1);
-              new_l1 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b1) - sizeof (*ip4_1) -
-                sizeof (*udp1) - GTPU_V1_HDR_LEN);
-              gtpu1->length = new_l1;
-              gtpu1->ver_flags |=
-                (upf_buffer_opaque (b1)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
-              gtpu2 = (gtpu_header_t *) (udp2 + 1);
-              new_l2 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b2) - sizeof (*ip4_2) -
-                sizeof (*udp2) - GTPU_V1_HDR_LEN);
-              gtpu2->length = new_l2;
-              gtpu2->ver_flags |=
-                (upf_buffer_opaque (b2)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
-              gtpu3 = (gtpu_header_t *) (udp3 + 1);
-              new_l3 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b3) - sizeof (*ip4_3) -
-                sizeof (*udp3) - GTPU_V1_HDR_LEN);
-              gtpu3->length = new_l3;
-              gtpu3->ver_flags |=
-                (upf_buffer_opaque (b3)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
             }
           else /* ipv6 */
             {
-              int bogus = 0;
-
               ip6_0 = vlib_buffer_get_current (b0);
               ip6_1 = vlib_buffer_get_current (b1);
               ip6_2 = vlib_buffer_get_current (b2);
@@ -754,46 +762,54 @@ upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
               /* Fix UDP length  and set source port */
               udp0 = (udp_header_t *) (ip6_0 + 1);
               udp0->length = new_l0;
-              udp0->src_port = flow_hash0;
               udp1 = (udp_header_t *) (ip6_1 + 1);
               udp1->length = new_l1;
-              udp1->src_port = flow_hash1;
               udp2 = (udp_header_t *) (ip6_2 + 1);
               udp2->length = new_l2;
-              udp2->src_port = flow_hash2;
               udp3 = (udp_header_t *) (ip6_3 + 1);
               udp3->length = new_l3;
-              udp3->src_port = flow_hash3;
+            }
 
-              /* Fix GTPU length */
-              gtpu0 = (gtpu_header_t *) (udp0 + 1);
-              new_l0 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b0) - sizeof (*ip6_0) -
-                sizeof (*udp0) - GTPU_V1_HDR_LEN);
-              gtpu0->length = new_l0;
-              gtpu0->ver_flags |=
-                (upf_buffer_opaque (b0)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
-              gtpu1 = (gtpu_header_t *) (udp1 + 1);
-              new_l1 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b1) - sizeof (*ip6_1) -
-                sizeof (*udp1) - GTPU_V1_HDR_LEN);
-              gtpu1->length = new_l1;
-              gtpu1->ver_flags |=
-                (upf_buffer_opaque (b1)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
-              gtpu2 = (gtpu_header_t *) (udp2 + 1);
-              new_l2 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b2) - sizeof (*ip6_2) -
-                sizeof (*udp2) - GTPU_V1_HDR_LEN);
-              gtpu2->length = new_l2;
-              gtpu2->ver_flags |=
-                (upf_buffer_opaque (b2)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
-              gtpu3 = (gtpu_header_t *) (udp3 + 1);
-              new_l3 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b3) - sizeof (*ip6_3) -
-                sizeof (*udp3) - GTPU_V1_HDR_LEN);
-              gtpu3->length = new_l3;
-              gtpu3->ver_flags |=
-                (upf_buffer_opaque (b3)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
+          /* Set UDP source port */
+          udp0->src_port = flow_hash0;
+          udp1->src_port = flow_hash1;
+          udp2->src_port = flow_hash2;
+          udp3->src_port = flow_hash3;
+
+          /* Fix GTPU length */
+          gtpu0 = (gtpu_header_t *) (udp0 + 1);
+          gtpu0->length = clib_host_to_net_u16 (
+            vlib_buffer_length_in_chain (vm, b0) - ip_hdr_size -
+            sizeof (*udp0) - GTPU_V1_HDR_LEN);
+          gtpu0->ver_flags |=
+            (upf_buffer_opaque (b0)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
+          gtpu1 = (gtpu_header_t *) (udp1 + 1);
+          gtpu1->length = clib_host_to_net_u16 (
+            vlib_buffer_length_in_chain (vm, b1) - ip_hdr_size -
+            sizeof (*udp1) - GTPU_V1_HDR_LEN);
+          gtpu1->ver_flags |=
+            (upf_buffer_opaque (b1)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
+          gtpu2 = (gtpu_header_t *) (udp2 + 1);
+          gtpu2->length = clib_host_to_net_u16 (
+            vlib_buffer_length_in_chain (vm, b2) - ip_hdr_size -
+            sizeof (*udp2) - GTPU_V1_HDR_LEN);
+          gtpu2->ver_flags |=
+            (upf_buffer_opaque (b2)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
+          gtpu3 = (gtpu_header_t *) (udp3 + 1);
+          gtpu3->length = clib_host_to_net_u16 (
+            vlib_buffer_length_in_chain (vm, b3) - ip_hdr_size -
+            sizeof (*udp3) - GTPU_V1_HDR_LEN);
+          gtpu3->ver_flags |=
+            (upf_buffer_opaque (b3)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
+
+	  write_qfi (gtpu0, b0);
+	  write_qfi (gtpu1, b1);
+	  write_qfi (gtpu2, b2);
+	  write_qfi (gtpu3, b3);
+
+          if (!is_ip4)
+            {
+              int bogus = 0;
 
               /* IPv6 UDP checksum is mandatory */
               udp0->checksum =
@@ -915,6 +931,9 @@ upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
           /* Apply the rewrite string. $$$$ vnet_rewrite? */
           vlib_buffer_advance (b0, -(word) _vec_len (far0->forward.rewrite));
 
+	  /* If necessary, add space for GTPU PDU container ext. hdr. */
+	  advance_for_qfi (b0);
+
           if (is_ip4)
             {
               ip4_0 = vlib_buffer_get_current (b0);
@@ -940,27 +959,13 @@ upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
               ip4_0->checksum = ip_csum_fold (sum0);
               ip4_0->length = new_l0;
 
-              /* Fix UDP length and set source port */
               udp0 = (udp_header_t *) (ip4_0 + 1);
-              new_l0 = clib_host_to_net_u16 (
+              udp0->length = clib_host_to_net_u16 (
                 vlib_buffer_length_in_chain (vm, b0) - sizeof (*ip4_0));
-              udp0->length = new_l0;
-              udp0->src_port = flow_hash0;
-
-              /* Fix GTPU length */
-              gtpu0 = (gtpu_header_t *) (udp0 + 1);
-              new_l0 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b0) - sizeof (*ip4_0) -
-                sizeof (*udp0) - GTPU_V1_HDR_LEN);
-              gtpu0->length = new_l0;
-              gtpu0->ver_flags |=
-                (upf_buffer_opaque (b0)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
             }
 
           else /* ip6 path */
             {
-              int bogus = 0;
-
               ip6_0 = vlib_buffer_get_current (b0);
               /* Copy the fixed header */
               copy_dst0 = (u64 *) ip6_0;
@@ -974,19 +979,26 @@ upf_encap_inline (vlib_main_t *vm, vlib_node_runtime_t *node,
                 vlib_buffer_length_in_chain (vm, b0) - sizeof (*ip6_0));
               ip6_0->payload_length = new_l0;
 
-              /* Fix UDP length  and set source port */
               udp0 = (udp_header_t *) (ip6_0 + 1);
               udp0->length = new_l0;
-              udp0->src_port = flow_hash0;
+            }
 
-              /* Fix GTPU length */
-              gtpu0 = (gtpu_header_t *) (udp0 + 1);
-              new_l0 = clib_host_to_net_u16 (
-                vlib_buffer_length_in_chain (vm, b0) - sizeof (*ip6_0) -
-                sizeof (*udp0) - GTPU_V1_HDR_LEN);
-              gtpu0->length = new_l0;
-              gtpu0->ver_flags |=
-                (upf_buffer_opaque (b0)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
+          /* Set UDP source port */
+          udp0->src_port = flow_hash0;
+
+          /* Fix GTPU length */
+          gtpu0 = (gtpu_header_t *) (udp0 + 1);
+          gtpu0->length = clib_host_to_net_u16 (
+            vlib_buffer_length_in_chain (vm, b0) - ip_hdr_size -
+            sizeof (*udp0) - GTPU_V1_HDR_LEN);
+          gtpu0->ver_flags |=
+            (upf_buffer_opaque (b0)->gtpu.hdr_flags & GTPU_E_S_PN_BIT);
+
+          write_qfi (gtpu0, b0);
+
+          if (!is_ip4)
+            {
+              int bogus = 0;
 
               /* IPv6 UDP checksum is mandatory */
               udp0->checksum =
diff --git a/upf/upf_pfcp.c b/upf/upf_pfcp.c
index b5d6202..d810b55 100644
--- a/upf/upf_pfcp.c
+++ b/upf/upf_pfcp.c
@@ -961,6 +961,7 @@ pfcp_free_pdr (upf_pdr_t *pdr)
 {
   upf_adf_put_adr_db (pdr->pdi.adr.db_id);
   vec_free (pdr->pdi.acl);
+  vec_free (pdr->pdi.qfis);
   vec_free (pdr->urr_ids);
   vec_free (pdr->qer_ids);
 }
@@ -984,6 +985,7 @@ pfcp_make_pending_pdr (upf_session_t *sx)
           upf_pdr_t *pdr = vec_elt_at_index (pending->pdr, i);
 
           pdr->pdi.acl = vec_dup (vec_elt (active->pdr, i).pdi.acl);
+          pdr->pdi.qfis = vec_dup (vec_elt (active->pdr, i).pdi.qfis);
           pdr->urr_ids = vec_dup (vec_elt (active->pdr, i).urr_ids);
           pdr->qer_ids = vec_dup (vec_elt (active->pdr, i).qer_ids);
         }
@@ -1693,6 +1695,20 @@ ip4_address_mask_from_width (ip4_address_t *a, u32 width)
     }
 }
 
+always_inline void
+compile_qfi (const upf_pdr_t * pdr, upf_acl_t * acl)
+{
+  if (!vec_len (pdr->pdi.qfis))
+    {
+      acl->qfi = ~0;
+      return;
+    }
+
+  /* TODO: Match against multiple possible QFIs, perhaps with multiple ACL
+     rules. */
+  acl->qfi = pdr->pdi.qfis[0];
+}
+
 always_inline void
 compile_teid (const upf_pdr_t *pdr, upf_acl_t *acl)
 {
@@ -1826,6 +1842,7 @@ compile_pdi (int is_ip4, const upf_pdr_t *pdr, const acl_rule_t *rule,
   acl->pdr_idx = pdr_idx;
 
   compile_teid (pdr, acl);
+  compile_qfi (pdr, acl);
   compile_sdf (is_ip4, pdr, rule, acl);
   compile_ue_ip (is_ip4, pdr, acl);
 
@@ -2810,8 +2827,11 @@ process_qers (vlib_main_t *vm, upf_session_t *sess, struct rules *r,
       if (!qer)
         continue;
 
-      if (!(qer->flags & PFCP_QER_MBR))
-        continue;
+      if (qer->qfi != (u8)~0)
+        {
+          upf_buffer_opaque (b)->gtpu.qfi_present = 1;
+          upf_buffer_opaque (b)->gtpu.qfi = GTPU_PDU_CONT_QFI_MASK & qer->qfi;
+        }
 
       if (qer->gate_status[direction])
         {
@@ -2819,6 +2839,9 @@ process_qers (vlib_main_t *vm, upf_session_t *sess, struct rules *r,
           break;
         }
 
+      if (!(qer->flags & PFCP_QER_MBR))
+        continue;
+
       pol = pool_elt_at_index (gtm->qer_policers, qer->policer.value);
       col = vnet_police_packet (&pol->policer[direction], len, POLICE_CONFORM,
                                 time_in_policer_periods);
diff --git a/upf/upf_pfcp_api.c b/upf/upf_pfcp_api.c
index 0063859..abf935e 100644
--- a/upf/upf_pfcp_api.c
+++ b/upf/upf_pfcp_api.c
@@ -925,6 +925,9 @@ handle_create_pdr (upf_session_t *sx, pfcp_ie_create_pdr_t *create_pdr,
             }
         }
 
+      if (ISSET_BIT (pdr->pdi.grp.fields, PDI_QFI))
+        create->pdi.qfis = vec_dup (pdr->pdi.qfi);
+
       if (ISSET_BIT (pdr->pdi.grp.fields, PDI_SDF_FILTER))
         {
           pfcp_ie_sdf_filter_t *sdf;
@@ -1112,6 +1115,12 @@ handle_update_pdr (upf_session_t *sx, pfcp_ie_update_pdr_t *update_pdr,
             }
         }
 
+      if (ISSET_BIT (pdr->pdi.grp.fields, PDI_QFI))
+        {
+          vec_free (update->pdi.qfis);
+          update->pdi.qfis = vec_dup (pdr->pdi.qfi);
+        }
+
       if (ISSET_BIT (pdr->pdi.grp.fields, PDI_SDF_FILTER))
         {
           pfcp_ie_sdf_filter_t *sdf;
@@ -2118,10 +2127,14 @@ handle_create_qer (upf_session_t *sx, pfcp_ie_create_qer_t *create_qer,
           create->mbr = qer->mbr;
         }
 
+      if (ISSET_BIT (qer->grp.fields, CREATE_QER_QOS_FLOW_IDENTIFIER))
+        create->qfi = qer->qos_flow_identifier & GTPU_PDU_CONT_QFI_MASK;
+      else
+        create->qfi = ~0;
+
       // TODO: gbr;
       // TODO: packet_rate;
       // TODO: dl_flow_level_marking;
-      // TODO: qos_flow_identifier;
       // TODO: reflective_qos;
     }
 
@@ -2172,10 +2185,12 @@ handle_update_qer (upf_session_t *sx, pfcp_ie_update_qer_t *update_qer,
           update->mbr = qer->mbr;
         }
 
+      if (ISSET_BIT (qer->grp.fields, UPDATE_QER_QOS_FLOW_IDENTIFIER))
+        update->qfi = qer->qos_flow_identifier & GTPU_PDU_CONT_QFI_MASK;
+
       // TODO: gbr;
       // TODO: packet_rate;
       // TODO: dl_flow_level_marking;
-      // TODO: qos_flow_identifier;
       // TODO: reflective_qos;
     }
 
@@ -2627,6 +2642,9 @@ handle_session_establishment_request (pfcp_msg_t *msg,
   if ((r = handle_create_urr (sess, req->create_urr, now, resp)) != 0)
     goto out_send_resp;
 
+  if ((r = handle_create_qer (sess, req->create_qer, now, resp)) != 0)
+    goto out_send_resp;
+
   r = pfcp_update_apply (sess);
   upf_debug ("Apply: %d\n", r);
 
